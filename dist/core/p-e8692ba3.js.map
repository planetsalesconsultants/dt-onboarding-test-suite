{"version":3,"sources":["src/utils/helpers.ts"],"names":["inheritAttributes","el","attributes","attributeObject","forEach","attr","hasAttribute","value","getAttribute","removeAttribute","renderHiddenInput","container","name","disabled","input","querySelector","ownerDocument","createElement","type","classList","add","appendChild","addEventListener","eventName","callback","opts","window","win","config","Ionic","ael","get","_ael","removeEventListener","rel","_rel","debounceEvent","event","wait","original","_original","emit","debounce","bind","func","timer","args","clearTimeout","setTimeout"],"mappings":";;;MAYaA,EAAoB,CAACC,EAAiBC,EAAuB,MACxE,MAAMC,EAAwC,GAE9CD,EAAWE,SAAQC,IACjB,GAAIJ,EAAGK,aAAaD,GAAO,CACzB,MAAME,EAAQN,EAAGO,aAAaH,GAC9B,GAAIE,IAAU,KAAM,CAClBJ,EAAgBE,GAAQJ,EAAGO,aAAaH,GAE1CJ,EAAGQ,gBAAgBJ,OAIvB,OAAOF,SAcIO,EAAoB,CAC/BC,EACAC,EACAL,EACAM,KAEA,IAAIC,EAAQH,EAAUI,cAAc,mBACpC,IAAKD,EAAO,CACVA,EAAQH,EAAUK,cAAeC,cAAc,SAC/CH,EAAMI,KAAO,SACbJ,EAAMK,UAAUC,IAAI,aACpBT,EAAUU,YAAYP,GAExBA,EAAMD,SAAWA,EACjBC,EAAMF,KAAOA,EACbE,EAAMP,MAAQA,GAAS,UAGZe,EAAmB,CAACrB,EAASsB,EAAmBC,EAAeC,KAC1E,UAAYC,SAAmB,YAAa,CAC1C,MAAMC,EAAMD,OACZ,MAAME,EAASD,GAAOA,EAAIE,OAASF,EAAIE,MAAMD,OAC7C,GAAIA,EAAQ,CACV,MAAME,EAAMF,EAAOG,IAAI,QACvB,GAAID,EAAK,CACP,OAAOA,EAAI7B,EAAIsB,EAAWC,EAAUC,QAC/B,GAAIG,EAAOI,KAAM,CACtB,OAAOJ,EAAOI,KAAK/B,EAAIsB,EAAWC,EAAUC,KAKlD,OAAOxB,EAAGqB,iBAAiBC,EAAWC,EAAUC,UAGrCQ,EAAsB,CAAChC,EAASsB,EAAmBC,EAAeC,KAC7E,UAAYC,SAAmB,YAAa,CAC1C,MAAMC,EAAMD,OACZ,MAAME,EAASD,GAAOA,EAAIE,OAASF,EAAIE,MAAMD,OAC7C,GAAIA,EAAQ,CACV,MAAMM,EAAMN,EAAOG,IAAI,QACvB,GAAIG,EAAK,CACP,OAAOA,EAAIjC,EAAIsB,EAAWC,EAAUC,QAC/B,GAAIG,EAAOO,KAAM,CACtB,OAAOP,EAAOO,KAAKlC,EAAIsB,EAAWC,EAAUC,KAKlD,OAAOxB,EAAGgC,oBAAoBV,EAAWC,EAAUC,UAGxCW,EAAgB,CAACC,EAAqBC,KACjD,MAAMC,EAAYF,EAAcG,WAAaH,EAC7C,MAAO,CACLG,UAAWH,EACXI,KAAMC,EAASH,EAASE,KAAKE,KAAKJ,GAAWD,KAI1C,MAAMI,EAAW,CAACE,EAAgCN,EAAO,KAC9D,IAAIO,EACJ,MAAO,IAAIC,KACTC,aAAaF,GACbA,EAAQG,WAAWJ,EAAMN,KAASQ","sourcesContent":["import { EventEmitter } from '@stencil/core';\n\n/**\n * Elements inside of web components sometimes need to inherit global attributes\n * set on the host. For example, the inner button in `gr-button` should inherit\n * the `aria-label` attribute that developers set directly on `gr-button`. This\n * helper function should be called in componentWillLoad and assigned to a variable\n * that is later used in the render function.\n *\n * This does not need to be reactive as changing attributes on the host element\n * does not trigger a re-render.\n */\nexport const inheritAttributes = (el: HTMLElement, attributes: string[] = []) => {\n  const attributeObject: { [k: string]: any } = {};\n\n  attributes.forEach(attr => {\n    if (el.hasAttribute(attr)) {\n      const value = el.getAttribute(attr);\n      if (value !== null) {\n        attributeObject[attr] = el.getAttribute(attr);\n      }\n      el.removeAttribute(attr);\n    }\n  });\n\n  return attributeObject;\n};\n\n/**\n * This method is used to add a hidden input to a host element that contains\n * a Shadow DOM. It does not add the input inside of the Shadow root which\n * allows it to be picked up inside of forms. It should contain the same\n * values as the host element.\n *\n * @param container The element where the input will be added\n * @param name The name of the input\n * @param value The value of the input\n * @param disabled If true, the input is disabled\n */\nexport const renderHiddenInput = (\n  container: HTMLElement,\n  name: string,\n  value: string | undefined | null,\n  disabled: boolean,\n) => {\n  let input = container.querySelector('input.aux-input') as HTMLInputElement | null;\n  if (!input) {\n    input = container.ownerDocument!.createElement('input');\n    input.type = 'hidden';\n    input.classList.add('aux-input');\n    container.appendChild(input);\n  }\n  input.disabled = disabled;\n  input.name = name;\n  input.value = value || '';\n};\n\nexport const addEventListener = (el: any, eventName: string, callback: any, opts?: any) => {\n  if (typeof (window as any) !== 'undefined') {\n    const win = window as any;\n    const config = win && win.Ionic && win.Ionic.config;\n    if (config) {\n      const ael = config.get('_ael');\n      if (ael) {\n        return ael(el, eventName, callback, opts);\n      } else if (config._ael) {\n        return config._ael(el, eventName, callback, opts);\n      }\n    }\n  }\n\n  return el.addEventListener(eventName, callback, opts);\n};\n\nexport const removeEventListener = (el: any, eventName: string, callback: any, opts?: any) => {\n  if (typeof (window as any) !== 'undefined') {\n    const win = window as any;\n    const config = win && win.Ionic && win.Ionic.config;\n    if (config) {\n      const rel = config.get('_rel');\n      if (rel) {\n        return rel(el, eventName, callback, opts);\n      } else if (config._rel) {\n        return config._rel(el, eventName, callback, opts);\n      }\n    }\n  }\n\n  return el.removeEventListener(eventName, callback, opts);\n};\n\nexport const debounceEvent = (event: EventEmitter, wait: number): EventEmitter => {\n  const original = (event as any)._original || event;\n  return {\n    _original: event,\n    emit: debounce(original.emit.bind(original), wait),\n  } as EventEmitter;\n};\n\nexport const debounce = (func: (...args: any[]) => void, wait = 0) => {\n  let timer: any;\n  return (...args: any[]): any => {\n    clearTimeout(timer);\n    timer = setTimeout(func, wait, ...args);\n  };\n};\n"]}